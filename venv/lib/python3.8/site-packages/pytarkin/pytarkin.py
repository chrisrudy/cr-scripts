# -*- coding: utf-8 -*-

import beyondclient
import logging
import os
import platform
import re
import requests
import socket
import time

from google.protobuf.message import DecodeError
from sq_protos_py.squareup.sake import wire_format_pb2
from sq_protos_py.squareup.tarkin import tarkin_pb2


_TARKIN_DISTRIBUTIONS_ENDPOINT = 'distributions'
_TARKIN_READER_ASSETS_ENDPOINT = 'reader-assets'
_TARKIN_SQUID_ASSETS_ENDPOINT = 'x2-assets'
_TARKIN_TOKENS_ENDPOINT = 'audience-tokens'
_BEYONDCORP_URL_FMT = 'https://tarkin.{}sqprod.co/internal/'
_VIP_URL_FMT = 'https://tarkin.{}vip.{}.square/internal/'
_S2S_PATH_WORKER = {'CentOS': '/etc/pki/tls/',
                    'Ubuntu': '/etc/ssl/',
                    'Darwin': '/System/Library/OpenSSL/'}
_S2S_WORKER_CERT = 'certs/hwnode.pem'
_S2S_WORKER_KEY = 'private/hwnode.key'

_CERT_BUNDLE_PATH = {'CentOS': '/etc/ssl/certs/ca-bundle.crt',
                     'Ubuntu': '/etc/ssl/certs/ca-certificates.crt',
                     'Darwin': '/System/Library/OpenSSL/certs/curl_ca_cert_bundle.crt'}

_SQUID_PLATFORM = 'android_zip'
_SQUID_DEVICES = ['X2', 'X2B', 'T2', 'T2B']

_LOG = logging.getLogger()


class PyTarkinException(Exception):
    """Base Exception class for pytarkin"""


class TarkinException(PyTarkinException):
    """Exception returned when Tarkin returns an error HTTP code"""


class PyTarkinNotImplementedExeception(PyTarkinException, NotImplementedError):
    """Exception returned when [Py]Tarkin does not support the attempted operation"""


class PyTarkinValueException(PyTarkinException, ValueError):
    """Exception returned when there is an error in the input given to PyTarkin"""


# create firmware assets using a hoistrepo-api RTM manifest link
def create_firmware_assets_from_rtm_manifest(rtm_manifest_url, production=False):
    create_asset_request = tarkin_pb2.CreateReaderAssetsRequest()
    create_asset_request.rtm_manifest_url = rtm_manifest_url
    _make_request('post',
                  create_asset_request,
                  _TARKIN_READER_ASSETS_ENDPOINT,
                  tarkin_pb2.CreateAssetResponse,
                  production)


# The underlying asset creation on Tarkin is async. This method makes that synchronous.
# This method automatically creates user and userdebug versions on staging and only a
# user version on production.
# This method creates a critical and a noncritical version of the squid asset
def create_squid_assets(mr_application, sha, version, production=False):
    _validate_sha(sha)
    responses = {}
    retries = 12
    build_types = ['USER', 'USERDEBUG']
    if production:
        build_types = ['USER']

    while retries:
        for build_type in build_types:
            if build_type not in responses:
                responses[build_type] = {}
            build_type_response = responses[build_type]
            for critical in [True, False]:
                if critical not in build_type_response:
                    build_type_response[critical] = None
                specific_response = build_type_response[critical]

                if specific_response is None or not specific_response.created_asset_ids:
                    create_squid_asset_request = tarkin_pb2.CreateX2AssetRequest()
                    create_squid_asset_request.build_type = \
                        tarkin_pb2.CreateX2AssetRequest.BuildType.Value(build_type.upper())
                    create_squid_asset_request.sha = sha
                    create_squid_asset_request.version = version
                    create_squid_asset_request.critical = critical
                    create_squid_asset_request.application = mr_application
                    create_squid_asset_request.platform = _SQUID_PLATFORM
                    create_squid_asset_request.reader_type = _squid_device(mr_application)
                    build_type_response[critical] = _make_request('post',
                                                                  create_squid_asset_request,
                                                                  _TARKIN_SQUID_ASSETS_ENDPOINT,
                                                                  tarkin_pb2.CreateAssetResponse,
                                                                  production)

        if all(resp and resp.created_asset_ids
               for responses_by_type in responses.values()
               for resp in responses_by_type.values()):
            return True

        # Wait 10 seconds and try again
        time.sleep(10)
        retries -= 1

    return False


# Returns an id if the specified squid asset already exists, starts creating one if it does not
def get_squid_asset_id(mr_application, sha, version, build_type='USERDEBUG', critical=False, production=False):
    _validate_sha(sha)
    create_squid_asset_request = tarkin_pb2.CreateX2AssetRequest()
    create_squid_asset_request.build_type = tarkin_pb2.CreateX2AssetRequest.BuildType.Value(
        build_type.upper())
    create_squid_asset_request.sha = sha
    create_squid_asset_request.version = version
    create_squid_asset_request.critical = critical
    create_squid_asset_request.application = mr_application
    create_squid_asset_request.platform = _SQUID_PLATFORM
    create_squid_asset_request.reader_type = _squid_device(mr_application)
    response = _make_request('post',
                             create_squid_asset_request,
                             _TARKIN_SQUID_ASSETS_ENDPOINT,
                             tarkin_pb2.CreateAssetResponse,
                             production)
    if len(response.created_asset_ids) == 1:
        return response.created_asset_ids[0]
    if len(response.created_asset_ids) > 1:
        _LOG.warning('More than 1 ID available for resource')
        return response.created_asset_ids[0]

    _LOG.warning('ID not available for resource')
    return None


# device is a case-insensitive string e.g. 'x2' or 'R12'
def link_asset(device, audience_id, asset_id, production=False):
    link_asset_request = tarkin_pb2.LinkAssetRequest()
    link_asset_request.reader_type = tarkin_pb2.ReaderType.Value(device.upper())
    link_asset_request.audience_id = audience_id
    link_asset_request.asset_id = asset_id
    link_asset_request.notes = 'Configured via API from %s' % socket.gethostname()
    return _make_request('post',
                         link_asset_request,
                         _TARKIN_DISTRIBUTIONS_ENDPOINT,
                         tarkin_pb2.LinkAssetResponse,
                         production)


# device is a case-insensitive string e.g. 'x2' or 'R12'
def unlink_asset(device, audience_id, asset_id, production=False):
    unlink_asset_request = tarkin_pb2.UnlinkAssetRequest()
    unlink_asset_request.reader_type = tarkin_pb2.ReaderType.Value(device.upper())
    unlink_asset_request.audience_id = audience_id
    unlink_asset_request.asset_id = asset_id
    return _make_request('delete',
                         unlink_asset_request,
                         _TARKIN_DISTRIBUTIONS_ENDPOINT,
                         tarkin_pb2.UnlinkAssetResponse,
                         production)


# gets the user tokens associated with an audience
def get_audience_user_tokens(audience_id, production=False):
    return add_audience_user_tokens(audience_id, [], production)


# user_tokens is a list of user token strings, returns a list of the audience's user tokens post-add
def add_audience_user_tokens(audience_id, user_tokens, production=False):
    add_user_tokens_request = tarkin_pb2.AddAudienceTokensRequest()
    add_user_tokens_request.audience_id = audience_id
    add_user_tokens_request.token_type = tarkin_pb2.USER_TOKEN
    add_user_tokens_request.tokens.extend(user_tokens)
    return _make_request('post',
                         add_user_tokens_request,
                         _TARKIN_TOKENS_ENDPOINT,
                         tarkin_pb2.AudienceTokensResponse,
                         production).tokens


# user_tokens is a list of user token strings, returns a list of the audience's user tokens post-delete
def remove_audience_user_tokens(audience_id, user_tokens, production=False):
    remove_user_tokens_request = tarkin_pb2.RemoveAudienceTokensRequest()
    remove_user_tokens_request.audience_id = audience_id
    remove_user_tokens_request.token_type = tarkin_pb2.USER_TOKEN
    remove_user_tokens_request.tokens.extend(user_tokens)
    return _make_request('delete',
                         remove_user_tokens_request,
                         _TARKIN_TOKENS_ENDPOINT,
                         tarkin_pb2.AudienceTokensResponse,
                         production).tokens


# gets the hardware ids associated with an audience
def get_audience_hwids(audience_id, production=False):
    return add_audience_hwids(audience_id, [], production)


# hwids is a list of hardware id strings, returns a list of the audience's hwids post-add
def add_audience_hwids(audience_id, hwids, production=False):
    add_hwids_request = tarkin_pb2.AddAudienceTokensRequest()
    add_hwids_request.audience_id = audience_id
    add_hwids_request.token_type = tarkin_pb2.HARDWARE_ID
    add_hwids_request.tokens.extend(hwids)
    return _make_request('post',
                         add_hwids_request,
                         _TARKIN_TOKENS_ENDPOINT,
                         tarkin_pb2.AudienceTokensResponse,
                         production).tokens


# hwids is a list of hardware id strings, returns a list of the audience's hwids post-delete
def remove_audience_hwids(audience_id, hwids, production=False):
    remove_hwids_request = tarkin_pb2.RemoveAudienceTokensRequest()
    remove_hwids_request.audience_id = audience_id
    remove_hwids_request.token_type = tarkin_pb2.HARDWARE_ID
    remove_hwids_request.tokens.extend(hwids)
    return _make_request('delete',
                         remove_hwids_request,
                         _TARKIN_TOKENS_ENDPOINT,
                         tarkin_pb2.AudienceTokensResponse,
                         production).tokens


def _make_request(request_method, request_proto, endpoint, response_proto_class, production=True):
    _LOG.debug('=>', request_proto.__class__.__name__)
    _LOG.debug(request_proto)

    if os.path.exists(_s2s_cert_path()) and os.path.exists(_s2s_key_path()):
        url = _vip_url(production)
        cert = (_s2s_cert_path(), _s2s_key_path())
        s = requests.Session()
        https = requests.adapters.HTTPAdapter(max_retries=5)
        s.mount('https://', https)
    else:
        url = _beyondcorp_url(production)
        cert = ''
        s = beyondclient.session()

    url += endpoint
    headers = {'Origin': socket.gethostname(),
               'Accept': '*/*',
               'Content-Type': 'application/x-protobuf'}

    response = getattr(s, request_method)(url,
                                          data=request_proto.SerializeToString(),
                                          headers=headers,
                                          cert=cert,
                                          verify=False)

    http_ok = response.status_code < 400

    response_proto = response_proto_class() if http_ok else wire_format_pb2.Error()
    try:
        response_proto.ParseFromString(response.content)
    except DecodeError as exc:
        print(response.content)
        raise exc

    _LOG.debug('<=', response_proto.__class__.__name__)
    _LOG.debug(response_proto)

    if not http_ok:
        raise TarkinException(
            u'Tarkin returned a %s: %s' % (response.status_code, response_proto.debug_text))

    return response_proto


def _s2s_cert_path():
    return ''.join([_S2S_PATH_WORKER[_os_name()], _S2S_WORKER_CERT])


def _s2s_key_path():
    return ''.join([_S2S_PATH_WORKER[_os_name()], _S2S_WORKER_KEY])


def _os_name():
    if platform.platform().startswith('Linux'):
        osname = re.split('[^a-zA-Z]', platform.linux_distribution()[0])[0]
    else:
        osname = re.split('[^a-zA-Z]', platform.platform())[0]
    return osname


def _set_cert_bundle():
    osname = _os_name()
    os.environ['REQUESTS_CA_BUNDLE'] = os.path.join(_CERT_BUNDLE_PATH[osname])


def _vip_url(production):
    if production:
        return _VIP_URL_FMT.format('', 'sjc2b')
    else:
        return _VIP_URL_FMT.format('stage.', 'sjc1')


def _beyondcorp_url(production):
    return _BEYONDCORP_URL_FMT.format('' if production else 'stage.')


def _squid_device(mr_application):
    parts = mr_application.split('-')
    device = parts[0].upper()
    if device not in _SQUID_DEVICES:
        raise PyTarkinNotImplementedExeception(
          'Only SWUP applications for the following devices are supported: ' + ', '.join(_SQUID_DEVICES))
    if 'swup' not in parts:
        raise PyTarkinNotImplementedExeception(
          'Only SWUP applications are supported. Perhaps you put the MR application incorrectly?')
    return tarkin_pb2.ReaderType.Value(device)


def _validate_sha(sha):
    if len(sha) != 40:
        raise PyTarkinValueException('SHA is not 40 characters long')
    elif re.match("^(([0-9a-fA-F]{40})|([0-9a-fA-F]{19}--[0-9a-fA-F]{19}))$", sha) is None:
        raise PyTarkinValueException('SHA contains invalid characters')
